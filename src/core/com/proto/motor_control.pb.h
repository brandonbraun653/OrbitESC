/* Automatically generated nanopb header */
/* Generated by nanopb-0.4.7 */

#ifndef PB_MOTOR_CONTROL_PB_H_INCLUDED
#define PB_MOTOR_CONTROL_PB_H_INCLUDED
#include <pb.h>

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Enum definitions */
typedef enum _MotorCtrlState {
    MotorCtrlState_MOTOR_CTRL_STATE_INVALID = 0, /* Invalid motor control state */
    MotorCtrlState_MOTOR_CTRL_STATE_IDLE = 1, /* Motor control is idle */
    MotorCtrlState_MOTOR_CTRL_STATE_ARMED = 2, /* Motor control is armed */
    MotorCtrlState_MOTOR_CTRL_STATE_ENGAGED = 3, /* Motor control is engaged */
    MotorCtrlState_MOTOR_CTRL_STATE_FAULT = 4 /* Motor control is in a fault state */
} MotorCtrlState;

typedef enum _MotorCtrlCmd {
    MotorCtrlCmd_MOTOR_CTRL_CMD_INVALID = 0, /* Invalid motor control command */
    MotorCtrlCmd_MOTOR_CTRL_CMD_ENABLE_OUTPUT_STAGE = 1, /* Allow the power stage to drive the motor */
    MotorCtrlCmd_MOTOR_CTRL_CMD_DISABLE_OUTPUT_STAGE = 2, /* Disable the power stage */
    MotorCtrlCmd_MOTOR_CTRL_CMD_EMERGENCY_STOP = 3 /* Immediately stop driving the power stage and halt */
} MotorCtrlCmd;

/* Struct definitions */
typedef struct _ManualICtrlSetPoint {
    float rotor_theta_rad;
    float id_ref;
    float iq_ref;
} ManualICtrlSetPoint;


#ifdef __cplusplus
extern "C" {
#endif

/* Helper constants for enums */
#define _MotorCtrlState_MIN MotorCtrlState_MOTOR_CTRL_STATE_INVALID
#define _MotorCtrlState_MAX MotorCtrlState_MOTOR_CTRL_STATE_FAULT
#define _MotorCtrlState_ARRAYSIZE ((MotorCtrlState)(MotorCtrlState_MOTOR_CTRL_STATE_FAULT+1))

#define _MotorCtrlCmd_MIN MotorCtrlCmd_MOTOR_CTRL_CMD_INVALID
#define _MotorCtrlCmd_MAX MotorCtrlCmd_MOTOR_CTRL_CMD_EMERGENCY_STOP
#define _MotorCtrlCmd_ARRAYSIZE ((MotorCtrlCmd)(MotorCtrlCmd_MOTOR_CTRL_CMD_EMERGENCY_STOP+1))



/* Initializer values for message structs */
#define ManualICtrlSetPoint_init_default         {0, 0, 0}
#define ManualICtrlSetPoint_init_zero            {0, 0, 0}

/* Field tags (for use in manual encoding/decoding) */
#define ManualICtrlSetPoint_rotor_theta_rad_tag  1
#define ManualICtrlSetPoint_id_ref_tag           2
#define ManualICtrlSetPoint_iq_ref_tag           3

/* Struct field encoding specification for nanopb */
#define ManualICtrlSetPoint_FIELDLIST(X, a) \
X(a, STATIC,   REQUIRED, FLOAT,    rotor_theta_rad,   1) \
X(a, STATIC,   REQUIRED, FLOAT,    id_ref,            2) \
X(a, STATIC,   REQUIRED, FLOAT,    iq_ref,            3)
#define ManualICtrlSetPoint_CALLBACK NULL
#define ManualICtrlSetPoint_DEFAULT NULL

extern const pb_msgdesc_t ManualICtrlSetPoint_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define ManualICtrlSetPoint_fields &ManualICtrlSetPoint_msg

/* Maximum encoded size of messages (where known) */
#define ManualICtrlSetPoint_size                 15

#ifdef __cplusplus
} /* extern "C" */
#endif

#ifdef __cplusplus
/* Message descriptors for nanopb */
namespace nanopb {
template <>
struct MessageDescriptor<ManualICtrlSetPoint> {
    static PB_INLINE_CONSTEXPR const pb_size_t fields_array_length = 3;
    static inline const pb_msgdesc_t* fields() {
        return &ManualICtrlSetPoint_msg;
    }
};
}  // namespace nanopb

#endif  /* __cplusplus */


#endif
